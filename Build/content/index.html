<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, proxy-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="cache-control" content="no-cache">
    <meta name="expires" content="Thu, 01 Jan 1970 00:00:00 GMT">
    <meta name="revisit-after" content="0">
    <title>JMDM Damage Meter v2.0</title>
    <style>
        :root {
        /* ìˆ˜ì •ê°€ëŠ¥ */
          /* ê¸°ë³¸ ë°°ê²½ ë° í…ìŠ¤íŠ¸ */
          --bg-color:         #1e1e1e;
          --bg-soft:          #2a2a2a;
          --text-color:       #e0e0e0;
          --text-dim:         #999999;
          --border-color:     #333333;
        
          /* ê°•ì¡° ë° ê¸°ëŠ¥ ìƒ‰  */
          --primary-color:    #4D9DE0; /* í•˜ëŠ˜ìƒ‰ ê°•ì¡° */
          --danger-color:     #FF6B6B; /* ê²½ê³  ë˜ëŠ” ê°•í•œ ë”œ */
          --success-color:    #7AE582; /* íšŒë³µ/ì™„ë£Œ */
          --warning-color:    #FFD93D; /* ê²½ê³ /ì£¼ì˜ */
        
          /* ê·¸ë˜í”„ ë“± ì‹œê°ì  ìš”ì†Œìš© */
          --bar-color-1:      #FF6B6B;
          --bar-color-2:      #4D9DE0;
          --bar-color-3:      #7AE582;
          --bar-bg:           rgba(255, 255, 255, 0.06);
        }
        body {
            font-family: 'ë§‘ì€ ê³ ë”•', 'Malgun Gothic', Arial, sans-serif;
            font-size: 1em;
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--text-color)
        }
        label {
            color: var(--text-color);
            font-size: 0.9em;
            margin-right: 8px;
            display: inline-block;
            vertical-align: middle;
        }

        .container {
            max-width: 1200px;
            margin: 40px auto;
            border-radius: 18px;
            box-shadow: 0 8px 32px rgba(60,60,120,0.10);
            padding: 36px 30px 28px 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 90vh;
        }
        .btn {
            background-color: var(--primary-color);
            color: black;
            padding: 7px 22px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.0em;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(60,60,120,0.07);
            transition: background 0.2s;
            outline: none;
        }
        .slt {
          background-color: #2a2a2a;
          color: #e0e0e0;
          border: 1px solid #444;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 0.9em;
          appearance: none;     /* í™”ì‚´í‘œ ì œê±° (ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥) */
          -webkit-appearance: none;
          -moz-appearance: none;
          background-image: url("data:image/svg+xml;charset=UTF-8,<svg fill='%23aaa' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
          background-repeat: no-repeat;
          background-position: right 10px center;
          background-size: 12px;
        }

        #conn-controls {
            display: inline-flex;
            margin-bottom: 18px;
            gap: 12px;
            align-items: center;
            justify-content: center;
            background: none;
            box-shadow: none;
        }
        #disconnectBtn {
            background: #43a047;
            color: #fff;
        }
        #disconnectBtn:hover {
            background: #388e3c;
        }
        #reconnectBtn {
            background: #e53935;
            color: #fff;
        }
        #reconnectBtn:hover {
            background: #b71c1c;
        }


        #damage-stats-panel {
            margin-bottom:18px;
            background:var(--bg-soft);
            border-radius:10px;
            padding:10px 16px;
            color:#444;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }
        
        .options-bar {
            display: flex;
            align-items: center;
            gap: 18px;
            margin-bottom: 2px;
            min-height: 32px;
        }
        .options-bar #conn-controls {
            justify-content: flex-end;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin: 0 0 0 18px;
            background: none;
            box-shadow: none;
            min-width: 120px;
        }
        .options-bar label {
            font-size: 1em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            user-select: none;
        }
        .options-bar input[type="checkbox"] {
            accent-color: #5a2d82;
            width: 18px;
            height: 18px;
            margin-right: 4px;
        }
        #damage-stats-list {
            margin:8px 0 0 18px;
            padding:0;
        }

        .runtime-bar {
            color: var(--text-color);
            margin: 8px 15px; 
            font-weight: bold;
        }

        
        .damage-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            background: var(--bg-soft);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .damage-table th {
            background: #3a3a3a;
            color: #e0e0e0;
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9em;
            border-bottom: 2px solid #4a4a4a;
        }
        
        .damage-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #333;
            font-size: 0.85em;
        }
        
        .damage-table tr:hover {
            background: rgba(77, 157, 224, 0.1);
        }
        
        .rank-row {
            background: linear-gradient(90deg, #2c3a45 20%, #1a232a 100%);
            color: #aac4d6;
            cursor: pointer;
            position: relative;
        }
        
        .rank-row.rank-1 {
            background: linear-gradient(90deg, #4a3e1a 20%, #2f2612 100%);
            color: #f3e38a;
            font-weight: bold;
        }
        
        .rank-row.rank-2 {
            background: linear-gradient(90deg, #3c3c3c 20%, #262626 100%);
            color: #d0d0d0;
        }
        
        .rank-row.rank-3 {
            background: linear-gradient(90deg, #4a2e1e 20%, #2b1a12 100%);
            color: #f3d8bd;
        }
        
        .user-cell {
            text-align: left !important;
            font-weight: bold;
            position: relative;
        }
        
        .user-badge {
            background: #445244;
            color: #d0c9f6;
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 0.8em;
            font-weight: 600;
            border: 1px solid #5a4a80;
        }
        
        .user-badge.me {
            background: #d73a29 !important;
            color: #fff !important;
            border: 1px solid #c85a7c !important;
        }
        
        .damage-value {
            font-weight: bold;
            color: #fff;
        }
        
        .contribution-value {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .dps-value {
            color: #4D9DE0;
            font-weight: bold;
        }
        
        .min-dps-value {
            color: #7AE582;
        }
        
        .max-dps-value {
            color: #FFD93D;
        }
        
        .crit-rate {
            color: #ff9800;
        }
        
        .add-rate {
            color: #9c27b0;
        }


        
        .detail-panel {
            margin-top: 18px;
            background: var(--bg-soft);
            border-radius: 16px;
            border: 2.5px solid #2a2a2a;
            box-shadow: 0 4px 24px rgba(255, 215, 64, 0.10), 0 1.5px 0 #2a2a2a inset;
            padding: 22px 36px;
            font-size: 1.13em;
            color: var(--text-color);
            min-height: 38px;
            position: static;
            left: unset;
            top: unset;
            transform: none;
            z-index: 20;
            margin-top: 18px;
            margin-bottom: 0;
            visibility: hidden;
        }
        .detail-panel.visible {
            visibility: visible;
        }
        /* detail-panel2ëŠ” detail-panelê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼ ì‚¬ìš© */
        #detail-panel2.detail-panel {
            margin-top: 12px;
        }
        .detail-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #ffb300;
            margin-bottom: 8px;
            display: block;
            letter-spacing: 1px;
        }
        .detail-stats {
            display: flex;
            flex-direction: column;
            gap: 7px;
            align-items: flex-start;
            font-size: 0.9em;
            margin-top: 2px;
        }
        .detail-label {
            color: var(--text-dim);
            font-weight: 600;
            font-size: 0.9em;
            margin-right: 2px;
        }
        .detail-value {
            color: #c0b0fa;
            font-weight: bold;
            font-size: 0.9em;
            margin-right: 10px;
        }
        .detail-dot {
            color: #d84315;
            font-weight: bold;
        }

        .skill-table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin-top: 22px;
            background: none;
            font-size: 0.9em;

            .skill-row {
                position: relative;
                display: flex;
                padding: 6px 12px;
                align-items: center;
                gap: 12px;
                font-size: 1em;
                cursor: pointer;
            }
            .skill-row .bar-bg {
              position: absolute;
              top: 2px;
              left: 0;
              bottom: 2px;
              background: #FF6B6B;
              opacity: 0.25;
              border-radius: 6px;
              z-index: 0;
              pointer-events: none;
            }         
            .skill-row > div {
              position: relative;
              z-index: 1;
              white-space: nowrap;
            }
            .skill-name {
              flex: 1;
            }
            .skill-damage, .skill-crit, .skill-addhit {
                font-size: 0.8em;
                text-align: right;
                min-width: 7em;
            }

            .skill-detail-row {
                position: relative;
                display: block;
                flex-wrap: wrap;
                gap: 12px;
                padding: 8px 122px 8px 12px; /* ì™¼ìª½ ì—¬ë°±ì€ ì¤„ì´ê³ , bar ê³µê°„ ê³ ë ¤í•œ ì˜¤ë¥¸ìª½ */
                background-color: #1f1f1f;
                border-left: 3px solid #4D9DE0; /* í¬ì¸íŠ¸ ì»¬ëŸ¬ */
                border-radius: 0 0 8px 8px;
                font-size: 0.85em;
                color: #ccc;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
                transition: background-color 0.2s ease;
            }
            .skill-detail-row > div{
                position: relative;
                display: flex;
                padding: 6px;
            }
            .skill-detail-row > div > div{
                padding-right: 1em;
            }
            .hidden {
                display: none;
            }   
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="damage-stats-panel">
            <div class="options-bar"> 
                <div id="conn-controls">
                    <button id="disconnectBtn" class="btn" style="display:none;">â›” ì—°ê²° ì¤‘ì§€</button>
                    <button id="reconnectBtn" class="btn">ğŸ”„ ì¬ì—°ê²°</button>
                </div>
                <button id="clearBtn" class="btn">ì´ˆê¸°í™”</button>
                <label for="calcmode">ì§‘ê³„ ë°©ì‹</label>
                <select id="calcmodechkbox" class="slt" name="calcmode">
                    <option value="all">ëª¨ë‘</option>
                    <option value="highest_hp">ìµœëŒ€ HP ëŒ€ìƒ</option>
                    <option value="most_attacked">ë”œ ì§‘ì¤‘ ëŒ€ìƒ</option>
                </select>
                <label>
                    <input type="checkbox" id="singleModeCheckbox">
                    <span>í—ˆìˆ˜ì•„ë¹„ ëª¨ë“œ</span>
                </label>
                <button id="saveAllBtn" class="btn">ì €ì¥</button>
                <button id="loadAllBtn" class="btn">ë¶ˆëŸ¬ì˜¤ê¸°</button>
            </div>
            <div id="runtime-display" class="runtime-bar">
                â±ï¸ ì „íˆ¬ì‹œê°„: <span id="runtime-text">0.00ì´ˆ</span>
            </div>            
            <table id="damage-stats-table" class="damage-table">
                <thead>
                    <tr>
                        <th>ìœ ì €</th>
                        <th>ì´ ë°ë¯¸ì§€</th>
                        <th>ê¸°ì—¬ë„</th>
                        <th>DPS</th>
                        <th>ìµœì†Œ DPS</th>
                        <th>ìµœëŒ€ DPS</th>
                        <th>ì¹˜ëª…íƒ€ìœ¨</th>
                        <th>ì¶”ê°€íƒ€ìœ¨</th>
                    </tr>
                </thead>
                <tbody id="damage-stats-list">
                </tbody>
            </table>
        </div>
        <div>
            <div id="detail-panel" class="detail-panel"></div>
        </div>
    </div>
    <script>
        let ws;
        const wsUrl = "ws://localhost:8080";
        const disconnectBtn = document.getElementById('disconnectBtn');
        const reconnectBtn = document.getElementById('reconnectBtn');
        const connControls = document.getElementById('conn-controls');

        const calcModeCheckBox = document.getElementById('calcmodechkbox');
        const bossCheckbox = document.getElementById('bossOnlyCheckbox');
        const singleModeCheckbox = document.getElementById('singleModeCheckbox');
        const clearBtn = document.getElementById('clearBtn');
        const runtimeText = document.getElementById('runtime-text');

        const damageByUser = {};
        const damageByTarget = {};
        const damageByUserBySkill = {};
        const selfDamageByUser = {}
        const damageForDPS = {};
        const timeForDPS = { start: 0, end: 0, timeByTarget: {}}
        
        // ì „íˆ¬ ìƒíƒœ ë° DPS ì¶”ì 
        const combatState = {
            isActive: false,
            startTime: 0,
            lastDamageTime: 0,
            minTrackingStartTime: 0,  // ìµœì†Œ DPS ì¶”ì  ì‹œì‘ ì‹œê°„ (ì „íˆ¬ ì‹œì‘ í›„ 10ì´ˆ)
            maxTrackingStartTime: 0   // ìµœëŒ€ DPS ì¶”ì  ì‹œì‘ ì‹œê°„ (ì „íˆ¬ ì‹œì‘ í›„ 10ì´ˆ)
        };
        const dpsStats = {}; // userIdë³„ DPS í†µê³„ (min, max, current)

        const jobMapping = {};
        const skillTrans = {src2name:{}, name2src:{}};
        const skillTrans2 = {src2name:{}}
        const skillTrans3 = {src2name:{}}
        const skillKey2Name = {}
        const dotFlag2Name = [
            ["bleed_flag", "ì¶œí˜ˆ"],
            ["dark_flag", "ì•”í‘"],
            ["fire_flag", "í™”ìƒ"],
            ["holy_flag", "ì‹ ì„±"],
            ["ice_flag", "ë¹™ê²°"],
            ["electric_flag", "ê°ì „"],
            ["poison_flag", "ì¤‘ë…"],
            ["mind_flag", "ì •ì‹ "],
            ["dump_flag123", "ë¬´ì†ì„±"]
        ];

        (function(){
            const dottypes = ["(ë„íŠ¸)", "(íŠ¹ìˆ˜)"];
            for(const dottype in dottypes){
                for(const [_,dotname] in dotFlag2Name){
                    dotkey = [dottype, dotname].join(" ")
                    skillKey2Name[dotkey] = dotkey;
                }
            }   
        })()

        const skillDetailOpened = {};        
        let selectedDetailUserId = null;
        (function(){
            document.getElementById('damage-stats-list').addEventListener('click', e => {
                const row = e.target.closest('.rank-row');
                if (!row) return;

                if (selectedDetailUserId === row.id) {
                    clearDetails();
                } else {
                    selectedDetailUserId = row.id;
                    showDetail(row.id);
                }
            });
            document.getElementById('detail-panel').addEventListener('click', e => {
                const row = e.target.closest('.skill-row');
                if (!row) return;

                const detail = row.nextElementSibling;
                if (detail && detail.classList.contains('skill-detail-row')) {
                    detail.classList.toggle('hidden');
                    skillDetailOpened[detail.id] = !detail.classList.contains('hidden');
                }
            });
        })()

        const bossTmpData = {id:0, hp:0};
        const selfTmpData = {id:0, total:0}
        
        let p_hpdff = null
        let bossOnly = false;
        let bossMode = null;
        let singleMode = false;
        let render_timeout = null;

        function getRuntimeMs(isBossMode, bossid){
            return isBossMode
                    ? timeForDPS.timeByTarget[bossid]
                        ? (timeForDPS.timeByTarget[bossid].end - timeForDPS.timeByTarget[bossid].start)
                        : 0
                    : (timeForDPS.end - timeForDPS.start);                    
        }

        function getTotalDamage(isBossMode, uid, bossid){
            return isBossMode 
                ? (damageForDPS[uid].total_by_target[bossid] ??  0) 
                : damageForDPS[uid].total;
        }

        function calcAddHitPercent(nAddHit, nAll) {
            return nAddHit ? nAddHit / (nAll-nAddHit) * 100 : 0;
        }

        function calcCritHitPercent(nCrit, nAll){
            return nCrit ? nCrit / nAll * 100 : 0;
        }

        // ì „íˆ¬ ìƒíƒœ ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function startCombat() {
            const now = Date.now();
            combatState.isActive = true;
            combatState.startTime = now;
            combatState.lastDamageTime = now;
            combatState.minTrackingStartTime = now + 10000; // 10ì´ˆ í›„ë¶€í„° ìµœì†Œ DPS ì¶”ì 
            combatState.maxTrackingStartTime = now + 10000; // 10ì´ˆ í›„ë¶€í„° ìµœëŒ€ DPS ì¶”ì 
            
            console.log("âš”ï¸ ì „íˆ¬ ì‹œì‘");
        }

        function endCombat() {
            combatState.isActive = false;
            console.log("ğŸ›¡ï¸ ì „íˆ¬ ì¢…ë£Œ");
        }

        function resetCombat() {
            // ìƒˆë¡œìš´ ì „íˆ¬ ì‹œì‘ - ì´ˆê¸°í™” ë²„íŠ¼ê³¼ ë™ì¼í•œ ë™ì‘
            console.log("ğŸ”„ ìƒˆë¡œìš´ ì „íˆ¬ ì‹œì‘ - ë°ì´í„° ì´ˆê¸°í™”");
            clearDPS();
            clearDamages();
            startCombat();
            // renderDamageRanks()ëŠ” í˜¸ì¶œí•˜ì§€ ì•ŠìŒ - ìƒˆ ë°ë¯¸ì§€ ì²˜ë¦¬ í›„ì— í˜¸ì¶œë¨
        }

        function updateDPSStats(userId) {
            if (!combatState.isActive) return;
            
            const now = Date.now();
            const combatTime = (now - combatState.startTime) / 1000;
            const totalDamage = damageByUser[userId]?.total || 0;
            const currentDPS = combatTime > 0 ? Math.floor(totalDamage / combatTime) : 0;
            
            if (!dpsStats[userId]) {
                dpsStats[userId] = {
                    min: Infinity,
                    max: 0,
                    current: currentDPS
                };
            }
            
            dpsStats[userId].current = currentDPS;
            
            // ìµœëŒ€ DPSëŠ” ì „íˆ¬ ì‹œì‘ í›„ 10ì´ˆ ì´í›„ë¶€í„°ë§Œ ì¶”ì 
            if (now >= combatState.maxTrackingStartTime && currentDPS > 0) {
                if (currentDPS > dpsStats[userId].max) {
                    dpsStats[userId].max = currentDPS;
                }
            }
            
            // ìµœì†Œ DPSëŠ” ì „íˆ¬ ì‹œì‘ í›„ 10ì´ˆ ì´í›„ë¶€í„°ë§Œ ì¶”ì 
            if (now >= combatState.minTrackingStartTime && currentDPS > 0) {
                if (dpsStats[userId].min === Infinity) {
                    dpsStats[userId].min = currentDPS;
                } else if (currentDPS < dpsStats[userId].min) {
                    dpsStats[userId].min = currentDPS;
                }
            }
        }

        function showDetail(user_id) {
            const detailDiv = document.getElementById('detail-panel');
            detailDiv.innerHTML = '';
            detailDiv.classList.remove('visible');

            const stat = damageByUser[user_id];
            const skillData = damageByUserBySkill[user_id];
            
            if (!stat || !skillData) {
                detailDiv.innerHTML = `<div style="color:#888;">ë°ì´í„° ì—†ìŒ</div>`;
                detailDiv.classList.add('visible');
                return;
            }
            const bossId = bossTmpData.id;
            const isBossMode = bossOnly && bossId;

            // ìŠ¤í‚¬ë³„ ë”œëŸ‰ ì§‘ê³„
            const skillRows = [];
            let total = 0;
            for (const skill in skillData) {
                const skillObj = isBossMode && skillData[skill].byTarget[bossId] ? skillData[skill].byTarget[bossId] : skillData[skill];                
                const dmg = skillObj ? skillObj.total || 0 : 0;
                if (dmg > 0) {     
                    const detail = {
                        crit: skillObj.count > 0 ? calcCritHitPercent(skillObj.cnt_crit, skillObj.count).toFixed(2) : ("+"+skillObj.cnt_crit), // íŒŒì£½ì§€ì„¸ë¡œ ë„íŠ¸ê°€ í¬ë¦¬í„°ì§€ëŠ” ê²½ìš° ê³ ë ¤
                        addhit: calcAddHitPercent(skillObj.cnt_addhit, skillObj.count).toFixed(2),
                        dot: skillObj.dot,
                        cnt: skillObj.count || 0,
                        cnt_dot: skillObj.cnt_dot || 0,
                        min_dmg: skillObj.count > 0 ? skillObj.min_dmg : 0,
                        max_dmg: skillObj.count > 0 ?  skillObj.max_dmg : 0,
                        min_dot_dmg: skillObj.cnt_dot > 0 ? skillObj.min_dot_dmg : 0,
                        max_dot_dmg: skillObj.cnt_dot > 0 ? skillObj.max_dot_dmg : 0,
                    }
                    skillRows.push({ skill, dmg, detail });
                    total += dmg;
                }
            }
            if (skillRows.length === 0) {
                detailDiv.innerHTML = `<div style="color:#888;">ë°ì´í„° ì—†ìŒ</div>`;
                detailDiv.classList.add('visible');
                return;
            }
            skillRows.sort((a, b) => b.dmg - a.dmg);

            const count = stat.count || 1;
            const critRate = calcCritHitPercent(stat.crit, count).toFixed(2);
            const addhitRate = calcAddHitPercent(stat.addhit, count).toFixed(2);
            let name;
            if (user_id == selfTmpData.id) {
                name = `<span class="rank-badge me" style="min-width:48px;display:inline-block;text-align:center;">${jobMapping[user_id] || user_id}</span>`;
            } else {
                name = `<span class="rank-badge" style="min-width:48px;display:inline-block;text-align:center;">${jobMapping[user_id] || user_id}</span>`;
            }
            shortDetailHtml = `
                <span class="detail-title">${name}</span>
                <div class="detail-stats">
                    <div><span class="detail-label">í¬ë¦¬ í™•ë¥ :</span>
                    <span class="detail-value">${critRate}%</span></div>
                    <div><span class="detail-label">ì¶”ê°€íƒ€ í™•ë¥ :</span>
                    <span class="detail-value">${addhitRate}%</span></div>
                </div>
            `;

            let table = `<div class="skill-table">`;
            skillRows.forEach((row, idx) => {
                const percent = total > 0 ? ((row.dmg / total) * 100).toFixed(2) : 0;
                // === ì˜¤ë²„ë© ê·¸ë˜í”„ ì¶”ê°€ ë¶€ë¶„ ì‹œì‘ ===
                const barColor = "#FF6B6B";
                // barì˜ heightë¥¼ 100%ê°€ ì•„ë‹ˆë¼ 90% ì •ë„ë¡œ, top/bottomì— ì—¬ë°±ì„ ì£¼ë©´ í–‰ë§Œ ë®ìŒ
                const bar = `<div style="
                    position:absolute;
                    left:0; top:2px; height:calc(100% - 4px); width:${percent}%;
                    background:${barColor};
                    opacity:0.28;
                    border-radius:6px;
                    z-index:0;
                    pointer-events:none;
                    transition:width 0.4s;
                "></div>`;
                const id = row.skill.replace(/[^\wê°€-í£]/g, '_');
                // === ì˜¤ë²„ë© ê·¸ë˜í”„ ì¶”ê°€ ë¶€ë¶„ ë ===
                table += `
                <div class="skill-row">
                    <div class="bar-bg" style="width: ${percent}%;"></div>
                    <div class="skill-name">${skillKey2Name[row.skill] ?? row.skill}</div>
                    <div class="skill-damage">${row.dmg.toLocaleString()} (${percent}%)</div>
                    <div class="skill-crit">í¬í™•: ${row.detail.crit}%</div>
                    <div class="skill-addhit">ì¶”í™•: ${row.detail.addhit}%</div>
                </div>
                <div id="${id}" 
                    class="skill-detail-row ${skillDetailOpened[id] ? "" : "hidden"}">
                    <div>
                        <div>íƒ€ê²©íšŸìˆ˜: ${row.detail.cnt}</div>
                        <div>ìµœëŒ€ ë°ë¯¸ì§€: ${row.detail.max_dmg}</div>
                        <div>ìµœì†Œ ë°ë¯¸ì§€: ${row.detail.min_dmg}</div>
                    </div>
                    <div>
                        <div>ë„íŠ¸íšŸìˆ˜: ${row.detail.cnt_dot}</div>
                        <div>ë„íŠ¸ë”œ: ${row.detail.dot} (${(row.detail.dot/row.dmg*100).toFixed(2)}%)</div>
                        <div>ë„íŠ¸ ìµœëŒ€: ${row.detail.max_dot_dmg}</div>
                        <div>ë„íŠ¸ ìµœì†Œ: ${row.detail.min_dot_dmg}</div>
                    </div>
                </div>
                `;
            });
            table += `</div>`;

            detailDiv.innerHTML = shortDetailHtml + table;            
            detailDiv.classList.add('visible');
        }

        function clearDetails() {
            selectedDetailUserId = null;
            const detailDiv = document.getElementById('detail-panel');
            detailDiv.classList.remove('visible');
        }

        function rankItem(rank, isSelf, jobName, total, dps, critRate, addhitRate, totalRate, minDPS, maxDPS){
            const tr = document.createElement('tr');
            tr.className = 'rank-row';

            if (rank === 0) tr.classList.add('rank-1');
            else if (rank === 1) tr.classList.add('rank-2');
            else if (rank === 2) tr.classList.add('rank-3');
            
            // ìœ ì € ì…€
            const userCell = document.createElement('td');
            userCell.className = 'user-cell';
            const badge = document.createElement('span');
            badge.className = 'user-badge' + (isSelf ? ' me' : '');
            badge.textContent = jobName;
            userCell.appendChild(badge);
            
            // ì´ ë°ë¯¸ì§€ ì…€
            const totalCell = document.createElement('td');
            totalCell.className = 'damage-value';
            totalCell.textContent = `${(total/10000).toFixed(1)}ë§Œ`;
            
            // ê¸°ì—¬ë„ ì…€
            const contributionCell = document.createElement('td');
            contributionCell.className = 'contribution-value';
            contributionCell.textContent = `${(totalRate*100).toFixed(1)}%`;
            
            // DPS ì…€
            const dpsCell = document.createElement('td');
            dpsCell.className = 'dps-value';
            dpsCell.textContent = `${(dps/10000).toFixed(1)}ë§Œ`;
            
            // ìµœì†Œ DPS ì…€
            const minDPSCell = document.createElement('td');
            minDPSCell.className = 'min-dps-value';
            minDPSCell.textContent = minDPS === Infinity ? '0ë§Œ' : `${(minDPS/10000).toFixed(1)}ë§Œ`;
            
            // ìµœëŒ€ DPS ì…€
            const maxDPSCell = document.createElement('td');
            maxDPSCell.className = 'max-dps-value';
            maxDPSCell.textContent = `${(maxDPS/10000).toFixed(1)}ë§Œ`;
            
            // ì¹˜ëª…íƒ€ìœ¨ ì…€
            const critCell = document.createElement('td');
            critCell.className = 'crit-rate';
            critCell.textContent = `${critRate.toFixed(1)}%`;
            
            // ì¶”ê°€íƒ€ìœ¨ ì…€
            const addCell = document.createElement('td');
            addCell.className = 'add-rate';
            addCell.textContent = `${addhitRate.toFixed(1)}%`;

            tr.appendChild(userCell);
            tr.appendChild(totalCell);
            tr.appendChild(contributionCell);
            tr.appendChild(dpsCell);
            tr.appendChild(minDPSCell);
            tr.appendChild(maxDPSCell);
            tr.appendChild(critCell);
            tr.appendChild(addCell);

            return tr;
        }

        // ë°ë¯¸ì§€ ìˆœìœ„ í‘œì‹œ í•¨ìˆ˜
        function renderDamageRanks() {
            let statsSource = damageByUser;
            // ë³´ìŠ¤ë§Œ ë³´ê¸° ì²´í¬ì‹œ bossTmpData.id ì‚¬ìš©
            if (bossOnly && bossTmpData.id && damageByTarget[bossTmpData.id]) {
                statsSource = damageByTarget[bossTmpData.id].byUser;
            }
            const totalSum = Object.values(statsSource)
                .reduce((sum, stat) => sum + (stat.total || 0), 0);

            const statsList = document.getElementById('damage-stats-list');
            while (statsList.firstChild) statsList.removeChild(statsList.firstChild);

            const sorted = Object.entries(statsSource)
                .sort((a, b) => b[1].total - a[1].total)
                .slice(0, 12);
            sorted
                .filter(([user_id, stat])=>
                    jobMapping[user_id] != null
                )
                .forEach(([user_id, stat], idx) => {
                    const total = stat.total || 0;
                    const dps = Math.floor(getTotalDamage(bossOnly, user_id, bossTmpData.id)/(getRuntimeMs(bossOnly, bossTmpData.id) / 1000+1));
                    const count = stat.count || 1;
                    const critRate = calcCritHitPercent(stat.crit, count);
                    const addhitRate = calcAddHitPercent(stat.addhit,count);
                    const totalRate = sorted.length === 1 ? 1 : totalSum > 0 ? total / totalSum : 0
                    const jobName =  jobMapping[user_id] ? jobMapping[user_id] : user_id;
                    const isSelf = selfTmpData.id == user_id;
                    
                    // 5ì´ˆê°„ DPSì˜ Min/Max ê°’ ê³„ì‚°
                    const userDPSStats = dpsStats[user_id] || { min: Infinity, max: 0, current: 0 };
                    const minDPS = userDPSStats.min === Infinity ? 0 : userDPSStats.min;
                    const maxDPS = userDPSStats.max || 0;
                    
                    const tr = rankItem(idx, isSelf, jobName, total, dps, critRate, addhitRate, totalRate, minDPS, maxDPS);
                    tr.id = user_id;
                    statsList.appendChild(tr);
                });

            // ë””í…Œì¼ íŒ¨ë„ ìƒíƒœ ìœ ì§€
            if (selectedDetailUserId && damageByUser[selectedDetailUserId]) {
                showDetail(selectedDetailUserId);
            } else {
                clearDetails();
            }
        }

        function clearDPS(){
            timeForDPS.start = timeForDPS.end  = 0; // ì•„ì£¼ ì˜›ë‚ ë¡œ
            Object.keys(timeForDPS.timeByTarget).forEach(key => {
                delete timeForDPS.timeByTarget[key];
            });
            Object.keys(damageForDPS).forEach(key => {
                damageForDPS[key].total = 0;
                damageForDPS[key].total_by_target = {};
            });
            // DPS í†µê³„ ì´ˆê¸°í™”
            Object.keys(dpsStats).forEach(key => {
                delete dpsStats[key];
            });
            // ì „íˆ¬ ìƒíƒœ ì´ˆê¸°í™”
            combatState.isActive = false;
            combatState.startTime = 0;
            combatState.lastDamageTime = 0;
            combatState.minTrackingStartTime = 0;
            combatState.maxTrackingStartTime = 0;
        }

        function clearDamages(){
            Object.keys(damageByUser).forEach(key => {
                delete damageByUser[key];
            });
            Object.keys(damageByTarget).forEach(key => {
                delete damageByTarget[key];
            });
            Object.keys(damageByUserBySkill).forEach(key => {
                delete damageByUserBySkill[key];
            });
            Object.keys(selfDamageByUser).forEach(key => {
                delete selfDamageByUser[key];
            });
            bossTmpData.hp = 0;
            selfTmpData.total = 0;
        }

        function updateBoss(tid, prev_hp, total){
            if (bossMode == "highest_hp") {
                if (bossTmpData.hp < prev_hp){
                    bossTmpData.id = tid;
                    bossTmpData.hp = prev_hp;
                }
            }
            else if(bossMode == "most_attacked"){
                if (bossTmpData.hp < total){
                    bossTmpData.id = tid;
                    bossTmpData.hp = total;
                }
            }
            else{
                bossTmpData.id = tid;
                bossTmpData.hp = total;
            }
        }

        function processDamage(dmg, uid, tid, flags, key1){
            const is_crit      = flags.crit_flag === 1;
            const is_addhit    = flags.add_hit_flag === 1;
            const is_dot       = (flags.dot_flag && flags.dot_flag2 && flags.dot_flag3) || flags.dot_flag4;
            const is_special   = flags.dot_flag || flags.dot_flag2 || flags.dot_flag3;

            const now = Date.now();
            
            // ì „íˆ¬ ìƒíƒœ ê´€ë¦¬
            if (!combatState.isActive) {
                // ì „íˆ¬ ì¢…ë£Œ í›„ ìƒˆë¡œìš´ ë°ë¯¸ì§€ê°€ ë“¤ì–´ì˜¤ë©´ ìƒˆ ì „íˆ¬ ì‹œì‘ (ë°ì´í„° ì´ˆê¸°í™”)
                if (combatState.lastDamageTime > 0) {
                    resetCombat();
                } else {
                    // ì²« ì „íˆ¬ ì‹œì‘
                    startCombat();
                }
            } else {
                // ë§ˆì§€ë§‰ ë°ë¯¸ì§€ë¡œë¶€í„° 3ì´ˆ ì´ìƒ ì§€ë‚¬ëŠ”ì§€ í™•ì¸
                if (now - combatState.lastDamageTime > 3000) {
                    // ì „íˆ¬ê°€ ëë‚¬ë‹¤ê°€ ìƒˆë¡œìš´ ë°ë¯¸ì§€ê°€ ë“¤ì–´ì˜¨ ìƒí™©
                    resetCombat();
                } else {
                    // ì „íˆ¬ ì§€ì† ì¤‘
                    combatState.lastDamageTime = now;
                }
            }

            if (!damageByUser[uid]) 
                damageByUser[uid] = {
                    count: 0,
                    total: 0,
                    crit: 0,
                    addhit: 0,
                }; 
            damageByUser[uid].total += dmg;
            if (!is_dot){
                damageByUser[uid].count++;
                damageByUser[uid].crit += is_crit;
                damageByUser[uid].addhit += is_addhit;
            }
                            
            if (!damageByTarget[tid]) 
                damageByTarget[tid] = { total: 0, byUser: {}};
            if (!damageByTarget[tid].byUser[uid]) 
                damageByTarget[tid].byUser[uid] = {
                    count: 0,
                    total: 0,
                    crit: 0,
                    addhit: 0,
                };
            damageByTarget[tid].total += dmg;
            damageByTarget[tid].byUser[uid].total += dmg;
            if(!is_dot){
                damageByTarget[tid].byUser[uid].count++;
                damageByTarget[tid].byUser[uid].crit += is_crit;
                damageByTarget[tid].byUser[uid].addhit += is_addhit;
            }

            if ((Date.now() - timeForDPS.end) > 1000 * 60){
                clearDPS();
                timeForDPS.start = Date.now();
                console.log("DPS ì´ˆê¸°í™”");
            }
            timeForDPS.end = Date.now();
            if (!timeForDPS.timeByTarget[tid]){
                timeForDPS.timeByTarget[tid] = {
                    start: Date.now(),
                    end: Date.now(),
                }
            }
            timeForDPS.timeByTarget[tid].end = Date.now();

            if (!damageForDPS[uid]){
                damageForDPS[uid] = {
                    total: 0,
                    total_by_target: {},
                };
            }
            damageForDPS[uid].total += dmg;
            if (!damageForDPS[uid].total_by_target[tid]) damageForDPS[uid].total_by_target[tid] = 0; 
            damageForDPS[uid].total_by_target[tid] += dmg;

            if(!damageByUserBySkill[uid])
                damageByUserBySkill[uid] = {}
            const damageByS = damageByUserBySkill[uid];
            let skey = null;
            if (key1 != 0){
                skey = skillTrans2.src2name[key1] || skillKey2Name[key1] || key1;               
            }
            else if(is_dot){
                const keyparts = ["(ë„íŠ¸)"];
                for (const [flag, label] of dotFlag2Name) if (flags[flag]) keyparts.push(label);
                if (keyparts.length == 1) keyparts.push("ë¬´ì†ì„±")
                skey = keyparts.join(" ")
            }
            else {            
                const keyparts = ["(íŠ¹ìˆ˜)"];
                for (const [flag, label] of dotFlag2Name) if (flags[flag]) keyparts.push(label);
                if (keyparts.length == 1) keyparts.push("ë¬´ì†ì„±")
                skey = keyparts.join(" ")
            }
            function skilldetailfact() {
                return {
                    total: 0,
                    dot: 0,
                    count: 0,
                    cnt_crit: 0,
                    cnt_addhit: 0,
                    cnt_dot: 0,
                    max_dmg: 0,
                    min_dmg: Infinity,
                    max_dot_dmg: 0,
                    min_dot_dmg: Infinity,
                };
            }
            if (!damageByS[skey]){
                damageByS[skey] = skilldetailfact();
                damageByS[skey].byTarget = {};
            }
            const dt = damageByS[skey];
            if (!dt.byTarget[tid]) {
                dt.byTarget[tid] = skilldetailfact();
            }
            const dtt = dt.byTarget[tid];
            for (const kkk of [dt, dtt]){            
                kkk.total += dmg;
                kkk.dot += is_dot ? dmg : 0;
                if (!is_dot){
                    is_crit      && kkk.cnt_crit++;
                    is_addhit    && kkk.cnt_addhit++;
                    kkk.count++;
                    kkk.max_dmg = Math.max(kkk.max_dmg, dmg);
                    kkk.min_dmg = Math.min(kkk.min_dmg, dmg);
                }
                else{
                    kkk.cnt_dot++;
                    kkk.max_dot_dmg = Math.max(kkk.max_dot_dmg, dmg);
                    kkk.min_dot_dmg = Math.min(kkk.min_dot_dmg, dmg);
                }
            }
            
            // DPS í†µê³„ ì—…ë°ì´íŠ¸
            updateDPSStats(uid);
        }

        function processJson(obj) {
            // objëŠ” {type: "json", hide: bool, data: [...]}
            let items = obj.data;
            if (!Array.isArray(items) || items.length === 0) return;

            // ì‚¬ìš©í•˜ëŠ” ë°ì´í„° ì²˜ë¦¬
            let updated = false;
            items.forEach(entry => {
                if (!entry || typeof entry !== "object") return;                
                switch (entry.type) {       
                    case 3:
                        if(entry.prev_hp > entry.current_hp && !singleMode){
                            p_hpdff = entry;
                        }
                        else {
                            p_hpdff = null;
                        }
                        break;
                    case 4:
                        {
                            if (entry.damage > 2095071572) return;

                            const uid = entry.user_id;
                            if(!selfDamageByUser[uid]) {
                                selfDamageByUser[uid] = {
                                    id: uid,
                                    total: 0,
                                };
                            }
                            selfDamageByUser[uid].total += entry.damage;

                            if (selfTmpData.total < selfDamageByUser[uid].total) {
                                selfTmpData.id = uid;
                                selfTmpData.total = selfDamageByUser[uid].total;
                            }
                            
                            if (singleMode){
                                p_hpdff = {
                                    prev_hp:entry.damage,
                                    current_hp:0,
                                    target_id:entry.target_id,
                                }
                            }
                        }
                        break;
                    case 1:
                        if(p_hpdff != null && entry.target_id == p_hpdff.target_id){
                            const dmg = Number(p_hpdff.prev_hp - p_hpdff.current_hp) || 0;
                            processDamage(dmg, entry.user_id, entry.target_id, entry.flags, entry.key1);
                            updateBoss(entry.target_id, p_hpdff.prev_hp, damageByTarget[entry.target_id].total);
                            updated = true;
                        }
                        break;
                    case 2:
                        {
                            const uid = entry.user_id;
                            const sk = entry.skill_name.toLowerCase();
                            if (!jobMapping[entry.user_id]) {

                                if(sk.includes("expertwarrior")) jobMapping[uid] = "ì „ì‚¬";
                                else if(sk.includes("greatsword")) jobMapping[uid] = "ëŒ€ê²€";
                                else if(sk.includes("swordmaster")) jobMapping[uid] = "ê²€ìˆ ";
                            
                                else if(sk.includes("healer")) jobMapping[uid] = "íëŸ¬";
                                else if(sk.includes("monk")) jobMapping[uid] = "ìˆ˜ë„";
                                else if(sk.includes("priest")) jobMapping[uid] = "ì‚¬ì œ";

                                else if(sk.includes("bard")) jobMapping[uid] = "ìŒìœ ";                            
                                else if(sk.includes("battlemusician")) jobMapping[uid] = "ì•…ì‚¬";
                                else if(sk.includes("dancer")) jobMapping[uid] = "ëŒ„ì„œ";
                            
                                else if(sk.includes("fighter")) jobMapping[uid] = "ê²©ê°€";
                                else if(sk.includes("dualblades")) jobMapping[uid] = "ë“€ë¸”";
                                else if(sk.includes("highthief")) jobMapping[uid] = "ë„ì ";
                            
                                else if(sk.includes("highmage")) jobMapping[uid] = "ë¸ë¯¸";
                                else if(sk.includes("firemage")) jobMapping[uid] = "í™”ë²•";
                                else if(sk.includes("icemage")) jobMapping[uid] = "ë¹™ê²°";
                                else if(sk.includes("lightningmage")) jobMapping[uid] = "ì „ê²©";

                                else if(sk.includes("higharcher")) jobMapping[uid] = "ê¶ìˆ˜";
                                else if(sk.includes("arbalist")) jobMapping[uid] = "ì„ê¶";
                                else if(sk.includes("longbowman")) jobMapping[uid] = "ì¥ê¶";

                                else if(sk.includes("novicewarrior_shieldbash")) jobMapping[uid] = null;
                                else if(sk.includes("novice")) jobMapping[uid] = "ë‰´ë¹„";
                                else if(sk.includes("defaultattack")) jobMapping[uid] = null;

                                else{
                                    jobMapping[uid] = null                           
                                }
                            }

                            if (!skillKey2Name[entry.key1] && !skillTrans3.src2name[entry.skill_name]){
                                skillKey2Name[entry.key1] = skillTrans.src2name[entry.skill_name] || entry.skill_name;
                            }
                        }
                        break;
                    default:
                        console.log("failed " + entry.type)
                        // í•„ìš”ì‹œ ë‹¤ë¥¸ íƒ€ì… ì²˜ë¦¬
                        break;
                }
            });
            if (updated) {
                if (render_timeout) return;
                render_timeout = setTimeout(() => {
                    renderDamageRanks();
                    render_timeout = null;
                }, 100);
            }
        }

        function setButtons(connected) {
            if (connected) {
                disconnectBtn.style.display = '';
                reconnectBtn.style.display = 'none';
                connControls.style.background = 'none';
            } else {
                disconnectBtn.style.display = 'none';
                reconnectBtn.style.display = '';
                connControls.style.background = 'none';
            }
        }

        function connect() {
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                setButtons(true);
            };

            ws.onmessage = (event) => {
                try {
                    const obj = JSON.parse(event.data);
                    switch (obj.type) {
                        case "json":
                            processJson(obj);
                            break;
                        case "skill":
                            skillTrans.src2name = obj.data;
                            break;
                        case "skill2":
                            skillTrans2.src2name = obj.data;
                            break;
                        case "skill3":
                            skillTrans3.src2name = obj.data;
                            break;
                        default:
                            console.warn("ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…:", obj.type);
                    }
                } catch (e) {
                    console.log("ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜:", e, event.data);
                }
            };

            ws.onclose = () => {
                setButtons(false);
            };

            ws.onerror = (err) => {
                setButtons(false);
            };
        }

        disconnectBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
        };
        reconnectBtn.onclick = () => {
            connect();
        };
        calcModeCheckBox.onchange = () => {
            bossOnly = calcModeCheckBox.value != "all";
            bossMode = calcModeCheckBox.value;                
            renderDamageRanks();
        };
        singleModeCheckbox.onchange = () => {
            singleMode = singleModeCheckbox.checked;                
            renderDamageRanks();
        };
        clearBtn.onclick = () => {
            clearDPS();
            clearDamages();
            renderDamageRanks();
        };;
        setInterval(() => {
            const elapsed = (getRuntimeMs(bossOnly, bossTmpData.id) / 1000).toFixed(2);
            
            // ì „íˆ¬ ìƒíƒœ í™•ì¸ ë° í‘œì‹œ
            let combatStatus = "ëŒ€ê¸°ì¤‘";
            if (combatState.isActive) {
                const now = Date.now();
                if (now - combatState.lastDamageTime > 3000) {
                    endCombat();
                    combatStatus = "ì „íˆ¬ì¢…ë£Œ";
                } else {
                    combatStatus = "ì „íˆ¬ì¤‘";
                }
            } else if (combatState.lastDamageTime > 0) {
                combatStatus = "ì „íˆ¬ì¢…ë£Œ";
            }
            
            runtimeText.textContent = `${elapsed}ì´ˆ (${combatStatus})`;
            
            // ì „íˆ¬ ì¤‘ì¼ ë•Œë§Œ DPS ì—…ë°ì´íŠ¸
            if (combatState.isActive) {
                Object.keys(damageByUser).forEach(userId => {
                    updateDPSStats(userId);
                });
            }
        }, 500);

        setButtons(false);
        connect();

        const saveAllBtn = document.getElementById('saveAllBtn');
        saveAllBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            function getKoreaTime(){
                const now = new Date();
                const kst = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Seoul' }));
                const yyyy = kst.getFullYear();
                const mm = String(kst.getMonth() + 1).padStart(2, '0');
                const dd = String(kst.getDate()).padStart(2, '0');
                const HH = String(kst.getHours()).padStart(2, '0');
                const MM = String(kst.getMinutes()).padStart(2, '0');
                const SS = String(kst.getSeconds()).padStart(2, '0');
                return `${yyyy}-${mm}-${dd}T${HH}-${MM}-${SS}`;
            }
            const data = {
                damageByUser,
                damageByTarget,
                damageByUserBySkill,
                selfDamageByUser,
                damageForDPS,
                timeForDPS,
                combatState,
                dpsStats,
                jobMapping,
                skillTrans,
                skillTrans2,
                skillTrans3,
                skillKey2Name,
                dotFlag2Name,
                bossTmpData,
                selfTmpData
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `savedata_${getKoreaTime()}.json`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        };

        // ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼ ë° íŒŒì¼ input ìƒì„±
        const loadAllBtn = document.getElementById('loadAllBtn');
        let fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';

        loadAllBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            fileInput.value = '';
            fileInput.click();
        };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    const data = JSON.parse(ev.target.result);
                    // === ê¸°ì¡´ ë°ì´í„° ì´ˆê¸°í™” ===
                    Object.keys(damageByUser).forEach(key => delete damageByUser[key]);
                    Object.keys(damageByTarget).forEach(key => delete damageByTarget[key]);
                    Object.keys(damageByUserBySkill).forEach(key => delete damageByUserBySkill[key]);
                    Object.keys(selfDamageByUser).forEach(key => delete selfDamageByUser[key]);
                    Object.keys(damageForDPS).forEach(key => delete damageForDPS[key]);
                    Object.keys(timeForDPS).forEach(key => delete timeForDPS[key]);
                    Object.keys(dpsStats).forEach(key => delete dpsStats[key]);
                    Object.keys(jobMapping).forEach(key => delete jobMapping[key]);
                    Object.keys(skillTrans).forEach(key => delete skillTrans[key]);
                    Object.keys(skillTrans2).forEach(key => delete skillTrans2[key]);
                    Object.keys(skillKey2Name).forEach(key => delete skillKey2Name[key]);
                    Object.keys(bossTmpData).forEach(key => delete bossTmpData[key]);
                    Object.keys(selfTmpData).forEach(key => delete selfTmpData[key]);
                    dotFlag2Name.length = 0;

                    // === ë¶ˆëŸ¬ì˜¨ ë°ì´í„° ì ìš© ===
                    Object.assign(damageByUser, data.damageByUser || {});
                    Object.assign(damageByTarget, data.damageByTarget || {});
                    Object.assign(damageByUserBySkill, data.damageByUserBySkill || {});
                    Object.assign(selfDamageByUser, data.selfDamageByUser || {});
                    Object.assign(damageForDPS, data.damageForDPS || {});
                    Object.assign(timeForDPS, data.timeForDPS || {});
                    Object.assign(combatState, data.combatState || { isActive: false, startTime: 0, lastDamageTime: 0, minTrackingStartTime: 0, maxTrackingStartTime: 0 });
                    Object.assign(dpsStats, data.dpsStats || {});
                    Object.assign(jobMapping, data.jobMapping || {});
                    Object.assign(skillTrans, data.skillTrans || {});
                    Object.assign(skillTrans2, data.skillTrans2 || {});
                    Object.assign(skillKey2Name, data.skillKey2Name || {});
                    Object.assign(bossTmpData, data.bossTmpData || {});
                    Object.assign(selfTmpData, data.selfTmpData || {});
                    if (Array.isArray(data.dotFlag2Name)) {
                        data.dotFlag2Name.forEach(v => dotFlag2Name.push(v));
                    }
                    renderDamageRanks();
                    // alert('ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                } catch (err) {
                    alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + err);
                }
            };
            reader.readAsText(file, 'utf-8');
        };
    </script>
</body>
</html>