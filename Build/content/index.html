<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        :root {
            /* 기본 배경 및 텍스트 */
            --bg-color:         #1e1e1e;
            --bg-soft:          #2a2a2a;
            --text-color:       #e0e0e0;
            --text-dim:         #999999;
            --border-color:     rgba(255,255,255,0.15); /* 테두리 */
            
            /* 강조 및 기능 색 */
            --primary-color:    #4D9DE0; /* 하늘색 강조 */
            --danger-color:     #FF6B6B; /* 경고 또는 강한 딜 */
            --success-color:    #7AE582; /* 회복/완료 */
            --warning-color:    #FFD93D; /* 경고/주의 */
            
            /* 그래프 등 시각적 요소용 */
            --bar-color-1:      #FF6B6B;
            --bar-color-2:      #4D9DE0;
            --bar-color-3:      #7AE582;
            --bar-bg:           rgba(255, 255, 255, 0.06);

            --btn-bg:         #2c2c2c;           /* 기본 배경 */
            --btn-bg-hover:   #3a3a3a;           /* 호버 배경 */
            --btn-border:     rgba(255,255,255,0.15);
            --btn-text:       #e0e0e0;
            --btn-text-hover: #ffffff;
            --btn-bg-active: #3a3a3a;
            --btn-text-active: #ffffff;

            --status-green: #00ffc3;  /* 연결됨 */
            --status-red:   #f44336;  /* 끊김 */
        }
        body {
            font-family: '맑은 고딕', 'Malgun Gothic', Arial, sans-serif;
            font-size: 1em;
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--text-color)
        }

        .container {
            max-width: 1200px;
            margin: 40px auto;
            border-radius: 18px;
            box-shadow: 0 8px 32px rgba(60,60,120,0.10);
            padding: 36px 30px 28px 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 90vh;
        }
        .panel {
            margin-bottom:18px;
            background:var(--bg-soft);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding:16px 20px;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }
        

        .btn {
            padding: 8px 16px;
            background: var(--btn-bg);
            color: var(--btn-text);
            border: 1px solid var(--btn-border);
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s, color 0.2s, transform 0.1s;
        }        
        .btn:hover {
            background: var(--btn-bg-hover);
            color: var(--btn-text-hover);
        }
        .btn:active {
            transform: scale(0.97); /* 눌린 효과 */
        }
        .btn.active {
            background: var(--btn-bg-active);  
            color: var(--btn-text-active);   
            box-shadow: 0 0 0 2px rgba(255,255,255,0.15); 
        }
        
        .status-indicator {
            display: inline-block; /* 반드시 필요 */
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            background-color: var(--status-red); /* 기본: 끊김 */
            border: 1px solid var(--status-border);
            box-shadow: 0 0 4px rgba(0,0,0,0.5); /* 다크모드 대비 */
            transition: background-color 0.3s;
        }
        .status-connected {
            background-color: var(--status-green);
        }

            
        input[type="checkbox"] {
            appearance: none;/* 기본 체크박스 제거 */
            width: 18px;
            height: 18px;
            margin-right: 4px;
            border-radius: 4px;
            border: 1px solid var(--text-dim);
            background-color: transparent;
            transition: background 0.2s, border 0.2s;
            display: grid;
            place-items: center;
        }
        input[type="checkbox"]:hover {
            border-color: var(--text-color);
        }
        input[type="checkbox"]::after {
            content: "✔";
            font-size: 12px;
            color: var(--text-color);
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.15s ease;
        }
        input[type="checkbox"]:checked::after {
            opacity: 1;
        }

        .combobox {
          background-color: #2a2a2a;
          color: #e0e0e0;
          border: 1px solid var(--border-color);
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 0.9em;
          appearance: none;     /* 화살표 제거 (커스터마이징 가능) */
          -webkit-appearance: none;
          -moz-appearance: none;
          background-image: url("data:image/svg+xml;charset=UTF-8,<svg fill='%23aaa' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
          background-repeat: no-repeat;
          background-position: right 10px center;
          background-size: 12px;
        }
        .divider {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 8px 0;
            opacity: 0.5;
        }
        
        /* Buff Monitor Dashboard */
        .buff-monitor {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(30, 30, 30, 0.6);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            min-height: 40px;
            align-items: center;
        }
        
        .buff-monitor-label {
            color: #888;
            font-size: 0.85em;
            margin-right: 8px;
        }
        
        .buff-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 4px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid rgba(60, 60, 60, 0.8);
            transition: all 0.3s ease;
        }
        
        .buff-indicator.active {
            background: rgba(76, 175, 80, 0.2);
            border-color: rgba(76, 175, 80, 0.5);
        }
        
        .buff-indicator.inactive {
            background: rgba(60, 60, 60, 0.2);
            border-color: rgba(80, 80, 80, 0.3);
            opacity: 0.6;
        }
        
        .buff-indicator .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .buff-indicator.active .status-dot {
            background: #4CAF50;
            box-shadow: 0 0 4px #4CAF50;
        }
        
        .buff-indicator.inactive .status-dot {
            background: #666;
        }
        
        .buff-indicator .buff-name {
            font-size: 0.8em;
            color: #fff;
        }


        .options-bar {
            display: flex;
            align-items: center;
            gap: 18px;
            margin-bottom: 2px;
            min-height: 32px;

            label {
                color: var(--btn-text);
                font-size: 0.9em;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 4px;
                cursor: pointer;
                user-select: none;
            }
        }


            
        .meter-wrapper {
            display: flex;
            align-items: center;
            gap: 12px; /* 바 사이 간격 */
            color: var(--text-color);
        }
        .my-text-box {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: rgba(40, 40, 40, 0.8); /* 반투명 다크 */
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            transition: background 0.3s;
            span {
                color: #00ffc3; /* 네온 민트 */
                font-weight: 600;
            }                
        }       
        
        #damage-stats-list {
            margin:8px 0 0 0;
            padding:0;
        }
        
        .rank-li {
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
            gap: 10px;
            padding: 6px 10px;
            color: var(--text-color); 
            font-weight: bold;
            margin-bottom: 3px;
            border-radius: 7px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;

            .rank-sub {
                font-size: 0.7em;
                z-index: 1;
            }
        }
        .rank-1 {
            color: #f3e38a;
        }
        .rank-2 {
            color: #d0d0d0;
        }
        .rank-3 {
            color: #f3d8bd;
        }
        .rank-nonmedal {
            font-weight:bold; 
            margin-right:4px;
            text-align: center; 
            width: 20px;
        }
        .rank-badge {
            display: inline-block;
            min-width: 48px;
            text-align: center;
            background: #445244;
            color: #d0c9f6;
            border-radius: 8px;
            padding: 2px 8px;
            font-size: 0.98em;
            font-weight: 600;
            margin-right: 8px;
            letter-spacing: 0.5px;
            box-sizing: border-box;
            transition: background 0.2s, color 0.2s, border 0.2s;
            border: 2px solid #5a4a80;
        }        
        .rank-badge.me {
            background: #4a2a3a !important;
            color: #ffb6c1 !important;
            border: 2px solid #c85a7c !important;
            font-weight: bold;
        }
        .rank-damage-share-bar {
            position: absolute;
            left: 110px;                /* badge + 여백 */
            top: 86%;
            height: 10%;
            opacity: 0.8;
            z-index: 0;
            pointer-events: none;
            transition: width 0.4s;
        }
        .rank-percent-label{
            margin-left: auto;
            font-size: 0.95em;
            color: var(--text-color);
            z-index: 1;
            position: relative;
        }


        
        .detail-panel {
            visibility: hidden;
        }
        .detail-panel.visible {
            visibility: visible;
        }
        .detail-title {
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
            gap: 10px;
            font-weight: bold;
            margin-bottom: 3px;
            border-radius: 7px;
        }
        .detail-stats {
            display: flex;
            flex-direction: column;
            gap: 7px;
            align-items: flex-start;
            font-size: 0.9em;
        }
        .detail-label {
            color: var(--text-dim);
            font-weight: 600;
            font-size: 0.9em;
            margin-right: 2px;
        }
        .detail-value {
            color: #c0b0fa;
            font-weight: bold;
            font-size: 0.9em;
            margin-right: 10px;
        }
        .detail-dot {
            color: #d84315;
            font-weight: bold;
        }

        .skill-table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin-top: 12px;
            background: none;
            font-size: 0.9em;

            .skill-row {
                position: relative;
                display: flex;
                padding: 6px 12px;
                align-items: center;
                gap: 12px;
                font-size: 1em;
                cursor: pointer;
            }
            .skill-row .bar-bg {
              position: absolute;
              top: 2px;
              left: 0;
              bottom: 2px;
              background: #FF6B6B;
              opacity: 0.25;
              border-radius: 6px;
              z-index: 0;
              pointer-events: none;
            }         
            .skill-row > div {
              position: relative;
              z-index: 1;
              white-space: nowrap;
            }
            .skill-name {
              flex: 1;
            }
            .skill-damage {
                font-size: 0.7em;
                text-align: right;
                min-width: 6em;
            }
            .skill-crit, .skill-addhit {
                font-size: 0.8em;
                text-align: left;
                min-width: 6em;
            }

            .skill-detail-row {
                position: relative;
                display: block;
                flex-wrap: wrap;
                gap: 12px;
                padding: 8px 122px 8px 12px; /* 왼쪽 여백은 줄이고, bar 공간 고려한 오른쪽 */
                background-color: #1f1f1f;
                border-radius: 0 0 8px 8px;
                font-size: 0.85em;
                color: #ccc;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
                transition: background-color 0.2s ease;
            }
            .skill-detail-row > div{
                position: relative;
                display: flex;
                padding: 6px;
            }
            .skill-detail-row > div > div{
                padding-right: 1em;
            }
            .hidden {
                display: none;
            }   
        }

        .buff-item {
            flex: 0 0 25%; 
            display:flex; 
            align-items: center; 
            justify-content: flex-start; 
            white-space: nowrap; 
            border-radius: 8px 8px;
            border: 1px solid var(--border-color);
            padding: 10px;
            
            .circle {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background-color: #007bff;
                display: inline-block;
                margin-right: 16px;                
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <div class="options-bar"> 
                <button class="btn" id="connectBtn">
                    연결 상태:
                    <span id="connectSym" class="status-indicator"></span>
                </button>
                <button id="clearBtn" class="btn">초기화</button>
                <button id="saveAllBtn" class="btn">저장</button>
                <button id="loadAllBtn" class="btn">불러오기</button>

                <label for="calcmode">집계 방식</label>
                <select id="calcmodechkbox" class="combobox" name="calcmode">
                    <option value="all">모두</option>
                    <option value="highest_hp">최대 HP 대상</option>
                    <option value="most_attacked">딜 집중 대상</option>
                </select>
                <label>
                    <span>허수아비 모드</span>
                    <input type="checkbox" id="singleModeCheckbox">
                </label>
            </div>
        </div>
        <div class="panel">
            <div class="meter-wrapper">
                <div id="combat-status" class="my-text-box" style="background: rgba(40, 40, 40, 0.9); border-color: rgba(255,255,255,0.2);">
                    <span id="combat-status-icon">⏳</span>
                    <span id="combat-status-text" style="font-weight: 600;">대기중</span>
                </div>
                <div id="runtime-display" class="my-text-box">
                    전투 시간: <span id="runtime-text">0.00초</ssapan>
                </div>
                <div id="runtime-total" class="my-text-box">
                    전체 딜량: <span id="total-text">0</span>
                </div>
                <div id="runtime-total" class="my-text-box">
                    전체 DPS: <span id="total-dps-text">0</span>
                </div>
            </div>
            <hr class="divider">
            
            <!-- Buff Monitor Dashboard -->
            <div class="buff-monitor" id="buff-monitor">
                <span class="buff-monitor-label">버프 모니터:</span>
                <!-- Buff indicators will be dynamically added here -->
            </div>
            
            <ol id="damage-stats-list"></ol>
        </div>
        <div id="detail-panel" class="panel detail-panel">
            <div id="detail-title-panel"  style="padding: 8px 0px;"></div>
            <hr class="divider">
            <div id="stat-detail-panel"  style="padding: 8px 12px;">
                <div class="detail-stats">
                    <div class="meter-wrapper">
                        <div class="my-text-box">크리 확률:<span class="detail-value">0%</span></div>
                        <div class="my-text-box">추가타 확률:<span class="detail-value">0%</span></div>
                        <div class="my-text-box">평균 공증:<span class="detail-value">0%</span></div>
                        <div class="my-text-box">평균 피증:<span class="detail-value">0%</span></div>
                    </div>
                    <div class="my-text-box" style="display: block; width: 100%;">
                        <div id="buff-radio-groups" style="display: flex; align-items: center; gap:12px;">
                            <div class="btn">전체</div>
                            <div class="btn">룬</div>
                            <div class="btn">스킬</div>
                            <div class="btn">시너지</div>
                            <div class="btn">보스</div>
                            <div style="color: var(--text-dim)">(버프 가동률 / 최대 스택)</div>
                        </div>
                        <div class="buff-list" style="display: flex; align-items: flex-start; flex-wrap: wrap; gap:12px; margin:20px 0px">
                            
                        </div>
                        <div class="buff-list" style="display: flex; align-items: flex-start; gap:12px; margin-top:10px">
                            
                        </div>
                    </div>
                </div>
            </div>
            <hr class="divider">
            <div id="skill-detail-panel" style="padding: 0px 6px; font-size: 1.13em"></div>
        </div>
    </div>
    <script>
        const wsUrl = "ws://localhost:8080/ws";
        let ws;
        
        // Convert C# PascalCase to JavaScript camelCase
        function convertData(data) {
            if (data === null || data === undefined) return data;
            if (Array.isArray(data)) return data.map(convertData);
            if (typeof data !== 'object') return data;
            
            const converted = {};
            for (const key in data) {
                let newKey = key;
                // Convert common property names
                switch(key) {
                    case 'All': newKey = 'all'; break;
                    case 'Normal': newKey = 'normal'; break;
                    case 'Dot': newKey = 'dot'; break;
                    case 'Special': newKey = 'special'; break;
                    case 'Buff': newKey = 'buff'; break;
                    case 'TotalDamage': newKey = 'total_damage'; break;
                    case 'TotalCount': newKey = 'total_count'; break;
                    case 'CritCount': newKey = 'crit_count'; break;
                    case 'AddHitCount': newKey = 'addhit_count'; break;
                    case 'PowerCount': newKey = 'power_count'; break;
                    case 'FastCount': newKey = 'fast_count'; break;
                    case 'MaxDamage': newKey = 'max_damage'; break;
                    case 'MinDamage': newKey = 'min_damage'; break;
                    case 'TotalAtk': newKey = 'total_atk'; break;
                    case 'TotalDmg': newKey = 'total_dmg'; break;
                    case 'MaxStack': newKey = 'max_stack'; break;
                    case 'TotalStack': newKey = 'total_stack'; break;
                    case 'Type': newKey = 'type'; break;
                    case 'Job': newKey = 'job'; break;
                    case 'AtkBuff': newKey = 'atk_buff'; break;
                    case 'DmgBuff': newKey = 'dmg_buff'; break;
                    case 'Buffs': newKey = 'buff'; break;
                    case 'BuffType': newKey = 'buff_type'; break;
                    case 'BuffName': newKey = 'buff_name'; break;
                    case 'BuffKey': newKey = 'buff_key'; break;
                    case 'BuffStack': newKey = 'buff_stack'; break;
                    case 'TargetId': newKey = 'target_id'; break;
                }
                converted[newKey] = convertData(data[key]);
            }
            return converted;
        }

        let damageDB  = {0:{0:{"":{}}}}
        let damageDB2 = {0:{0:{"":{}}}}
        let buffDB = {};
        let selfID = 0;
        let enemyData = {}
        let userData = {}
        let hitTime = {};
        let dpsStats = {};
        let combatState = { is_active: false, duration: 0 };
        let userTmpData = {}
        let buffMonitorData = {};

        let bossMode = "all";
        let singleMode = false;
        let render_timeout = null;
        let buffVisibleTypes = {}
        
        let clearTime = 0;  // 초기화 시점 기록

        const skillDetailOpened = {};        
        let selectedDetailUserId = null;
        (function(){
            document.getElementById('damage-stats-list').addEventListener('click', e => {
                const row = e.target.closest('.rank-li');
                if (!row) return;
                
                if (selectedDetailUserId === row.id) {
                    clearDetails();
                } else {
                    selectedDetailUserId = row.id;
                    showDetail(row.id);
                }
            });
            document.getElementById('detail-panel').addEventListener('click', e => {
                const row = e.target.closest('.skill-row');
                if (!row) return;

                const detail = row.nextElementSibling;
                if (detail && detail.classList.contains('skill-detail-row')) {
                    detail.classList.toggle('hidden');
                    skillDetailOpened[detail.id] = !detail.classList.contains('hidden');
                }
            });
        })()

        function getTargetID(){
            if (bossMode == "all"){
                return 0;
            }
            else if (bossMode == "highest_hp") {
                return enemyData.max_hp_tid;
            }
            else if(bossMode == "most_attacked"){
                return enemyData.most_attacked_tid;
            }
            else{
                return enemyData.last_attacked_tid;
            }
        }
        function getRuntimeSec(){
            tid = getTargetID();
            return hitTime[tid]
                        ? (hitTime[tid].end - hitTime[tid].start)
                        : 0;                    
        }
        function getTotalDamage(isSingle){
            const sorted = calcSoredItems()
            const totalSum = sorted.reduce((sum, [uid,stat]) => sum + (stat[""].all.total_damage || 0), 0);
            return totalSum;
        }
        function calcAddHitPercent(item) {
            if (item == null) return 0;
            const nAddHit = item.normal.addhit_count + item.special.addhit_count;
            const nAll = item.normal.total_count + item.special.total_count;
            return nAddHit ? (nAddHit / (nAll-nAddHit) * 100).toFixed(2) : 0;
        }
        function calcCritHitPercent(item){
            if (item == null) return 0;
            const nCrit = item.normal.crit_count + item.special.crit_count;
            const nAll = item.normal.total_count + item.special.total_count;
            return nCrit ? (nCrit / nAll * 100).toFixed(2) : 0;
        }
        function divideForDis(numerator, denominator){
            return denominator > 0 ? (numerator / denominator).toFixed(2) : 0;
        }
        function calcPercent(numerator, denominator){
            return denominator > 0 ? (numerator / denominator * 100).toFixed(2) : 0;
        }

        function showDetail(uid) {
            const detailDiv = document.getElementById('detail-panel');
            detailDiv.classList.remove('visible');
            
            const tid = getTargetID();
            const db = singleMode  ? damageDB2 : damageDB;
            if (db[uid] && db[uid][tid]){
                renderDetailTitle(uid)
                renderDetail(uid)
                renderSkillDetail(uid)
            }

            detailDiv.classList.add('visible');
        }
        function renderDetailTitle(uid){
            const detailDiv = document.getElementById('detail-title-panel');
            while (detailDiv.firstChild) detailDiv.removeChild(detailDiv.firstChild);

            const sorted = calcSoredItems()
            const totalSum = sorted.reduce((sum, [uid,stat]) => sum + (stat[""].all.total_damage || 0), 0);

            sorted.forEach(([user_id, item], idx) => {
                    if(user_id != uid) return;

                    const stat = item[""];

                    const total = stat.all.total_damage || 0;
                    const critRate   = calcCritHitPercent(stat);
                    const addhitRate = calcAddHitPercent(stat);
                    const atkbuff    = divideForDis(stat.buff.total_atk, stat.buff.total_count);
                    const dmgbuff    = divideForDis(stat.buff.total_dmg, stat.buff.total_count);
                    const dps        = Math.floor(total/(getRuntimeSec()+1));
                    const totalRate = sorted.length === 1 ? 1 : totalSum > 0 ? total / totalSum : 0
                    const jobName =  userData[user_id] ? userData[user_id].job : user_id;
                    const isSelf = selfID == user_id;

                    const li = rankItem(idx, isSelf, jobName, total, totalRate, dps, critRate, addhitRate, atkbuff, dmgbuff);
                    detailDiv.appendChild(li);
                });
        }
        function renderDetail(uid) {
            const tid = getTargetID();
            const db = singleMode  ? damageDB2[uid][tid][""] : damageDB[uid][tid][""]; 
            
            const rank = calcSoredItems().findIndex(([id, item]) => id === uid);
            const critRate  = calcCritHitPercent(db);
            const addhitRate = calcAddHitPercent(db);
            const atkbuff = divideForDis(db.buff.total_atk, db.buff.total_count);
            const dmgbuff = divideForDis(db.buff.total_dmg, db.buff.total_count);
            
            // 모든 detail-value span을 가져오기
            const values = document.querySelectorAll('#stat-detail-panel .detail-value');
            values[0].textContent = `${critRate}%`; 
            values[1].textContent = `${addhitRate}%`; 
            values[2].textContent = `${atkbuff}`;
            values[3].textContent = `${dmgbuff}`;
            

            const buffList = document.querySelectorAll('#stat-detail-panel .buff-list')[0];
            buffList.innerHTML = '';

            const buffs = buffDB[uid] ? buffDB[uid][tid][""] : {}
            const types = {"룬":1, "스킬":11, "시너지":12, "보스":21};
            const colors = {1:"E68A2E", 11:"2E7DD9", 12:"36CC6D", 21:"A05ED9"};
            for (const [buffTypeName, buffTypeCode] of Object.entries(types)) 
            {
                if (buffVisibleTypes[buffTypeName] != true) continue;

                buffList.innerHTML += Object.entries(buffs)
                    .filter(([key, v])=>v.type == buffTypeCode).map((
                    [key, value])=>`
                        <div class="buff-item">
                            <div class="circle" style="background:#${colors[buffTypeCode]};""></div>
                            ${key}&nbsp;
                            <span class="detail-value">(${calcPercent(value.total_stack/value.max_stack, db.normal.total_count + db.special.total_count)}% / ${value.max_stack})</span>
                        </div>`)
                    .join("")
            }

            if (userTmpData && userTmpData[uid] && userTmpData[uid].buff){
                const buffList = document.querySelectorAll('#stat-detail-panel .buff-list')[1];
 
                shortBuffHtml2 = Object.entries(userTmpData[uid].buff).map(([key, value])=>{
                    const buffKey = value.buff_key || key;
                    const buffName = value.buff_name || "";
                    const displayName = buffName && buffName !== buffKey ? `${buffName}(${buffKey})` : buffKey;
                    return `<span class="detail-value">${displayName}(${value.buff_stack || 0})</span>`;
                }).join("")
                buffList.innerHTML = `
                    <div class="my-text-box" style="display: flex; align-items: center; width: 100%;">
                        <span class="detail-label" style="margin-right: 8px;">버프:</span>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px; flex: 1;">
                            ${shortBuffHtml2}
                        </div>
                    </div>
                `
            }
        }
        function renderSkillDetail(uid) {
            const detailDiv = document.getElementById('skill-detail-panel');
            detailDiv.innerHTML = '';

            const targetID = getTargetID();
            const db = singleMode  ? damageDB2[uid][targetID] : damageDB[uid][targetID]; 

            // 스킬별 딜량 집계
            const skillRows = [];
            let total = 0;
            for (const skill in db) {
                if (skill == "") continue;
                const skillObj = db[skill];
                const dmg = skillObj ? skillObj.all.total_damage || 0 : 0;
                if (dmg > 0) {
                    const normal = skillObj.normal;
                    const dot = skillObj.dot;
                    const special = skillObj.special;
                    const detail = {
                        total: skillObj.all.total_damage,
                        crit: calcCritHitPercent(skillObj),
                        addhit: calcAddHitPercent(skillObj),
                        atk: divideForDis(skillObj.buff.total_atk, skillObj.buff.total_count),
                        dmg: divideForDis(skillObj.buff.total_dmg, skillObj.buff.total_count),
                    }
                    skillRows.push({ skill, dmg, detail, normal, dot, special });
                    total += dmg;
                }
            }
            if (skillRows.length === 0) {
                return;
            }
            skillRows.sort((a, b) => b.dmg - a.dmg);

            let table = `<div class="skill-table">`;
            skillRows.forEach((row, idx) => {
                const percent = calcPercent(row.dmg, total);
                // === 오버랩 그래프 추가 부분 시작 ===
                const barColor = "#FF6B6B";
                // bar의 height를 100%가 아니라 90% 정도로, top/bottom에 여백을 주면 행만 덮음
                const bar = `<div style="
                    position:absolute;
                    left:0; top:2px; height:calc(100% - 4px); width:${percent}%;
                    background:${barColor};
                    opacity:0.28;
                    border-radius:6px;
                    z-index:0;
                    pointer-events:none;
                    transition:width 0.4s;
                "></div>`;
                const id = row.skill.replace(/[^\w가-힣]/g, '_');
                // === 오버랩 그래프 추가 부분 끝 ===
                table += `
                <div class="skill-row">
                    <div class="bar-bg" style="width: ${percent}%;"></div>
                    <div class="skill-name">${row.skill}</div>
                    <div class="skill-damage">${row.dmg.toLocaleString()} (${percent}%)</div>
                    <div class="skill-crit">공증: ${row.detail.atk}%</div>
                    <div class="skill-crit">피증: ${row.detail.dmg}%</div>
                    <div class="skill-crit">크확: ${row.detail.crit}%</div>
                    <div class="skill-addhit">추확: ${row.detail.addhit}%</div>
                </div>
                <div id="${id}" 
                    class="skill-detail-row ${skillDetailOpened[id] ? "" : "hidden"}">
                    <div>
                        <div>일반 타수: ${row.normal.total_count}</div>
                        <div>총합: ${row.normal.total_damage}(${calcPercent(row.normal.total_damage,row.detail.total)}%)</div>
                        <div>최대: ${row.normal.max_damage}</div>
                        <div>최소: ${row.normal.min_damage}</div>
                        <div>강타: ${calcPercent(row.normal.power_count, row.normal.total_count)}%</div>
                        <div>연타: ${calcPercent(row.normal.fast_count, row.normal.total_count)}%</div>
                        <div>치명: ${calcPercent(row.normal.crit_count, row.normal.total_count)}%</div>
                    </div>
                    <div>
                        <div>도트 타수: ${row.dot.total_count}</div> 
                        <div>총합: ${row.dot.total_damage}(${calcPercent(row.dot.total_damage,row.detail.total)}%)</div>                      
                        <div>최대: ${row.dot.max_damage}</div>
                        <div>최소: ${row.dot.min_damage}</div>
                        <div>강타: ${calcPercent(row.dot.power_count, row.dot.total_count)}%</div>
                        <div>연타: ${calcPercent(row.dot.fast_count, row.dot.total_count)}%</div>
                        <div>치명: ${row.dot.crit_count}</div>
                    </div>
                    <div>
                        <div>특수 타수: ${row.special.total_count}</div>
                        <div>총합: ${row.special.total_damage}(${calcPercent(row.special.total_damage,row.detail.total)}%)</div>    
                        <div>최대: ${row.special.max_damage}</div>
                        <div>최소: ${row.special.min_damage}</div>
                        <div>강타: ${calcPercent(row.special.power_count,row.special.total_count)}%</div>
                        <div>연타: ${calcPercent(row.special.fast_count,row.special.total_count)}%</div>
                        <div>치명: ${calcPercent(row.special.crit_count,row.special.total_count)}%</div>
                    </div>
                </div>
                `;
            });
            table += `</div>`;

            detailDiv.innerHTML = table;
        }

        function clearDetails() {
            selectedDetailUserId = null;
            const detailDiv = document.getElementById('detail-panel');
            detailDiv.classList.remove('visible');
        }
        
        let lastCombatEndTime = 0;
        let lastCombatActiveState = false;
        const COMBAT_END_DISPLAY_TIME = 5000; // 전투 종료 표시를 5초간 유지
        let AUTO_RESET_DELAY = 30000; // 전투 종료 후 새 전투 시작하면 자동 초기화 (기본값 30초)
        
        function updateBuffMonitor() {
            const monitorDiv = document.getElementById('buff-monitor');
            
            // Clear existing indicators except label
            const indicators = monitorDiv.querySelectorAll('.buff-indicator');
            indicators.forEach(indicator => indicator.remove());
            
            if (!buffMonitorData || Object.keys(buffMonitorData).length === 0) {
                return;
            }
            
            for (const [buffId, buffInfo] of Object.entries(buffMonitorData)) {
                const indicator = document.createElement('div');
                indicator.className = `buff-indicator ${buffInfo.active ? 'active' : 'inactive'}`;
                
                const dot = document.createElement('div');
                dot.className = 'status-dot';
                
                const name = document.createElement('div');
                name.className = 'buff-name';
                // Display buff name with stack count if available
                let displayText = buffInfo.name || buffId;
                if (buffInfo.stack > 0) {
                    displayText += ` (${buffInfo.stack})`;
                }
                name.textContent = displayText;
                
                indicator.appendChild(dot);
                indicator.appendChild(name);
                monitorDiv.appendChild(indicator);
            }
        }
        
        function updateCombatStatus() {
            const statusDiv = document.getElementById('combat-status');
            const statusIcon = document.getElementById('combat-status-icon');
            const statusText = document.getElementById('combat-status-text');
            
            if (combatState.is_active) {
                // 전투중
                statusDiv.style.background = 'rgba(255, 107, 107, 0.2)'; // 붉은색 배경
                statusDiv.style.borderColor = 'rgba(255, 107, 107, 0.5)';
                statusIcon.textContent = '⚔️';
                statusText.textContent = '전투중';
                statusText.style.color = '#FF6B6B';
            } else if (lastCombatEndTime > 0 && Date.now() - lastCombatEndTime < COMBAT_END_DISPLAY_TIME) {
                // 전투 종료 (5초간 표시)
                statusDiv.style.background = 'rgba(122, 229, 130, 0.2)'; // 초록색 배경
                statusDiv.style.borderColor = 'rgba(122, 229, 130, 0.5)';
                statusIcon.textContent = '✓';
                statusText.textContent = '전투 종료';
                statusText.style.color = '#7AE582';
                
                // 5초 후 자동으로 대기중으로 전환
                setTimeout(() => {
                    if (!combatState.is_active) {
                        updateCombatStatus();
                    }
                }, COMBAT_END_DISPLAY_TIME);
            } else {
                // 대기중
                statusDiv.style.background = 'rgba(40, 40, 40, 0.9)';
                statusDiv.style.borderColor = 'rgba(255,255,255,0.2)';
                statusIcon.textContent = '⏳';
                statusText.textContent = '대기중';
                statusText.style.color = '#999999';
            }
        }

        function rankItem(rank, isSelf, jobName, total, totalRate, dps, critRate, addhitRate, atk, dmg, minDps, maxDps){
            const li = document.createElement('li');
            li.className = 'rank-li';

            if (rank === 0) li.classList.add('rank-1');
            else if (rank === 1) li.classList.add('rank-2');
            else if (rank === 2) li.classList.add('rank-3');
            
            const badge = document.createElement('span');
            badge.className = 'rank-badge' + (isSelf ? ' me' : '');
            badge.textContent = jobName;
            const totalSpan = document.createElement('span');
            totalSpan.className = 'rank-total';
            totalSpan.textContent = `총합: ${total.toLocaleString()}`;
            const dpsSpan = document.createElement('span');
            dpsSpan.className = 'rank-dps';
            dpsSpan.textContent = `DPS: ${dps.toLocaleString()}`;
            const minDpsSpan = document.createElement('span');
            minDpsSpan.className = 'rank-sub';
            minDpsSpan.textContent = `최저: ${(minDps || 0).toLocaleString()}`;
            const maxDpsSpan = document.createElement('span');
            maxDpsSpan.className = 'rank-sub';
            maxDpsSpan.textContent = `최고: ${(maxDps || 0).toLocaleString()}`;
            const critSpan = document.createElement('span');
            critSpan.className = 'rank-sub';
            critSpan.textContent = `치명타: ${critRate}%`;
            const addhitSpan = document.createElement('span');
            addhitSpan.className = 'rank-sub';
            addhitSpan.textContent = `추가타: ${addhitRate}%`;
            const atkSpan = document.createElement('span');
            atkSpan.className = 'rank-sub';
            atkSpan.textContent = `공증: ${atk}`;
            const dmgSpan = document.createElement('span');
            dmgSpan.className = 'rank-sub';
            dmgSpan.textContent = `피증: ${dmg}`;

            // 퍼센트 라벨(선택)
            const percentLabel = document.createElement('span');
            percentLabel.className = "rank-percent-label";
            // 행이 1개뿐이면 무조건 100%로 표기
            percentLabel.textContent = (totalRate*100).toLocaleString(undefined, {minimumFractionDigits: 1, maximumFractionDigits: 1}) + '%';

            // 순위
            const rankNum = document.createElement('span');
            rankNum.className = 'rank-nonmedal';
            rankNum.textContent = (rank + 1).toString().padStart(1, '0');
            li.appendChild(rankNum);

            // === 행 전체 배경 그래프 추가 ===
            const barColor = rank === 0 ? '#bfa642'
               : rank === 1 ? '#8e8e8e'  
               : rank === 2 ? '#c07e47' 
               : '#5a7391'; 
            const bar = document.createElement('div');
            bar.classList.add("rank-damage-share-bar");
            bar.style.background = barColor;
            bar.style.width = ((document.body.offsetWidth-232) * totalRate) + 'px'; //실제크기기반으로 하면 깜빡임 현상 있음

            badge.style.zIndex = '1';
            totalSpan.style.zIndex = '1';
            totalSpan.style.fontWeight = 'bold';
            dpsSpan.style.zIndex = '1';
            dpsSpan.style.fontWeight = 'bold';

            li.appendChild(bar);
            li.appendChild(badge);
            li.appendChild(totalSpan);
            li.appendChild(dpsSpan);
            li.appendChild(minDpsSpan);
            li.appendChild(maxDpsSpan);
            li.appendChild(critSpan);
            li.appendChild(addhitSpan);
            li.appendChild(atkSpan);
            li.appendChild(dmgSpan);
            li.appendChild(percentLabel);

            return li;
        }

        // 데미지 순위 표시 함수
        function renderDamageRanks() {
            // Update combat status
            updateCombatStatus();
            
            const statsList = document.getElementById('damage-stats-list');
            while (statsList.firstChild) statsList.removeChild(statsList.firstChild);

            const sorted = calcSoredItems()
            const totalSum = sorted.reduce((sum, [uid,stat]) => sum + (stat[""].all.total_damage || 0), 0);
            sorted.forEach(([user_id, item], idx) => {
                    const stat = item[""];

                    const total = stat.all.total_damage || 0;
                    const critRate   = calcCritHitPercent(stat);
                    const addhitRate = calcAddHitPercent(stat);
                    const atkbuff    = divideForDis(stat.buff.total_atk, stat.buff.total_count);
                    const dmgbuff    = divideForDis(stat.buff.total_dmg, stat.buff.total_count);
                    const dps        = Math.floor(total/(getRuntimeSec()+1));
                    const totalRate = sorted.length === 1 ? 1 : totalSum > 0 ? total / totalSum : 0
                    const jobName =  userData[user_id] ? userData[user_id].job : user_id;
                    const isSelf = selfID == user_id;
                    
                    // Get DPS stats from server data
                    const dpsData = dpsStats && dpsStats[user_id] ? dpsStats[user_id] : null;
                    const minDps = dpsData ? dpsData.min : 0;
                    const maxDps = dpsData ? dpsData.max : 0;

                    const li = rankItem(idx, isSelf, jobName, total, totalRate, dps, critRate, addhitRate, atkbuff, dmgbuff, minDps, maxDps);
                    li.id = user_id;
                    statsList.appendChild(li);
                });

            // 디테일 패널 상태 유지
            if (selectedDetailUserId) {
                showDetail(selectedDetailUserId);
            } else {
                clearDetails();
            }
        }

        function calcSoredItems(){
            const tid = getTargetID();
            const statsSource = singleMode ? damageDB2 : damageDB;
            if (statsSource == null) return [];
            const sorted = Object.entries(statsSource)
                .sort((a, b) => 
                    (b[1][tid] ? b[1][tid][""].all.total_damage : 0) - 
                    (a[1][tid] ? a[1][tid][""].all.total_damage : 0))
                .filter(([user_id, item])=>item[tid] != null)
                .filter(([user_id, item])=>userData[user_id] != null && userData[user_id].job.length > 0)
                .map(([key, item])=>[key, item[tid]])
                .slice(0, 12);

            return sorted;
        }

        function clearDB () {
            damageDB  = {0:{0:{"":{}}}}
            damageDB2 = {0:{0:{"":{}}}}
            buffDB = {};
            selfID = 0;
            enemyData = {}
            userData = {}
            hitTime = {};
            userTmpData = null;
            dpsStats = {};
            combatState = { is_active: false, duration: 0 };
   
            selectedDetailUserId = null;
        }

        (function() {
            singleMode = localStorage.getItem('singleMode') === 'true';
            bossMode = localStorage.getItem('bossMode') ?? "모두";
            buffVisibleTypes = JSON.parse(localStorage.getItem('buffVisibleTypes')) || {};

            const calcModeCheckBox = document.getElementById('calcmodechkbox');
            const singleModeCheckbox = document.getElementById('singleModeCheckbox');
            calcModeCheckBox.onchange = () => {
                bossMode = calcModeCheckBox.value;                
                renderDamageRanks();
                localStorage.setItem('bossMode', bossMode);
            };
            singleModeCheckbox.onchange = () => {
                singleMode = singleModeCheckbox.checked;                
                renderDamageRanks();
                localStorage.setItem('singleMode', singleMode);
            };
            singleModeCheckbox.checked = singleMode
            calcModeCheckBox.value = bossMode


            const group = document.getElementById('buff-radio-groups');
            const buttons = group.querySelectorAll('.btn');

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const labels = Array.from(buttons).map(b=>b.innerText.trim())
                    const label = btn.innerText.trim();
                    const state = btn.classList.contains('active');

                    if (label == "전체"){
                        if(state == true){
                            labels.forEach(l=>buffVisibleTypes[l]=false);
                            buttons.forEach(b => b.classList.remove('active'));
                        }
                        else{
                            labels.forEach(l=>buffVisibleTypes[l]=true);
                            buttons.forEach(b => b.classList.add('active'));
                        }
                    }
                    else{
                        if(state == true){                            
                            buffVisibleTypes[label] = false;
                            btn.classList.remove('active');
                            buttons[0].classList.remove('active');
                        }
                        else {
                            buffVisibleTypes[label] = true;
                            btn.classList.add('active');
                        }
                    }

                    localStorage.setItem('buffVisibleTypes', JSON.stringify(buffVisibleTypes));
                    renderDamageRanks();
                });
            });
            
           buttons.forEach(btn => {
                const labels = Array.from(buttons).map(b=>b.innerText.trim())
                const label = btn.innerText.trim();
                let state = false;
                if (label == "전체"){
                    state =  Object.values(buffVisibleTypes).every(v => v === true);
                }
                else{
                    state = buffVisibleTypes[label]
                }
                if(state == false){
                    btn.classList.remove('active');
                }
                else {
                    btn.classList.add('active');
                }                
            });

        })();

        const saveAllBtn = document.getElementById('saveAllBtn');
        saveAllBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            function getKoreaTime(){
                const now = new Date();
                const kst = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Seoul' }));
                const yyyy = kst.getFullYear();
                const mm = String(kst.getMonth() + 1).padStart(2, '0');
                const dd = String(kst.getDate()).padStart(2, '0');
                const HH = String(kst.getHours()).padStart(2, '0');
                const MM = String(kst.getMinutes()).padStart(2, '0');
                const SS = String(kst.getSeconds()).padStart(2, '0');
                return `${yyyy}-${mm}-${dd}T${HH}-${MM}-${SS}`;
            }
            const data = {
                damageDB,
                damageDB2,
                buffDB,
                selfID,
                enemyData,
                userData,
                hitTime
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `savedata_${getKoreaTime()}.json`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        };

        // 데이터 불러오기 버튼 및 파일 input 생성
        const loadAllBtn = document.getElementById('loadAllBtn');
        let fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';

        loadAllBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            fileInput.value = '';
            fileInput.click();
        };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    clearDB();
                    
                    const data = JSON.parse(ev.target.result);

                    // === 불러온 데이터 적용 ===
                    Object.assign(damageDB, data.damageDB || {});
                    Object.assign(damageDB2, data.damageDB2 || {});
                    Object.assign(buffDB, data.buffDB || {});
                    Object.assign(enemyData, data.enemyData || {});
                    Object.assign(userData, data.userData || {});
                    Object.assign(hitTime, data.hitTime || {});
                    selfID = data.selfID;

                    renderDamageRanks();
                    // alert('데이터를 성공적으로 불러왔습니다.');
                } catch (err) {
                    alert('불러오기 실패: ' + err);
                }
            };
            reader.readAsText(file, 'utf-8');
        };
        
        setInterval(() => {
            const elapsed = getRuntimeSec();
            const total = getTotalDamage(singleMode);
            document.getElementById('runtime-text').textContent = `${elapsed.toFixed(2)}초`;
            document.getElementById('total-text').textContent = `${total.toLocaleString()}`;
            document.getElementById('total-dps-text').textContent = `${Math.round(total/(elapsed+1)).toLocaleString()}`;
        }, 500);

        (function(){
            let isConnected = false;

            function onConnectionChanged(connected) {
                isConnected = connect;
                const ctrl = document.getElementById('connectSym');
                if (connected) {
                    ctrl.classList.add("status-connected")
                } else {
                    ctrl.classList.remove("status-connected")
                }
            }
            document.getElementById('connectBtn').onclick = () => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.close();
                }
                else{
                    connect()
                }
            }
            document.getElementById('clearBtn').onclick = () => {
                clearDB();
                lastCombatEndTime = 0;
                combatState.was_active = false;
                ws.close();
                connect();
                renderDamageRanks();
                updateCombatStatus();
            };

            function connect() {
                console.log("Connecting to WebSocket:", wsUrl);
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log("WebSocket connected successfully");
                    onConnectionChanged(true);
                };

                ws.onmessage = (event) => {
                    console.log("WebSocket message received:", event.data);
                    try {
                        const obj = JSON.parse(event.data);
                        console.log("Parsed message type:", obj.type);
                        switch (obj.type) {
                            case "damage":
                                damageDB   = convertData(obj.data.damage);
                                damageDB2  = convertData(obj.data.damage2);
                                selfID    = obj.data.self_id;
                                enemyData  = obj.data.enemy;
                                hitTime    = obj.data.hit_time;
                                buffDB = convertData(obj.data.buff);
                                if (obj.data.user) {
                                    userData = convertData(obj.data.user);
                                }
                                userTmpData = convertData(obj.data.user_tmp);
                                
                                // Update DPS stats and combat state
                                if (obj.data.dps_stats) {
                                    dpsStats = obj.data.dps_stats;
                                }
                                if (obj.data.combat_state) {
                                    combatState = obj.data.combat_state;
                                    
                                    // 전투가 종료되었을 때 시간 기록
                                    if (lastCombatActiveState && !combatState.is_active) {
                                        lastCombatEndTime = Date.now();
                                        console.log("Combat ended, recording end time");
                                    }
                                    
                                    // 대기중 또는 전투종료 상태에서 전투가 시작되면 자동 초기화
                                    if (!lastCombatActiveState && combatState.is_active) {
                                        // 전투 종료 후 설정된 시간이 지났으면 자동 초기화
                                        const timeSinceEnd = lastCombatEndTime > 0 ? Date.now() - lastCombatEndTime : 0;
                                        const shouldReset = lastCombatEndTime > 0 && timeSinceEnd > AUTO_RESET_DELAY;
                                        
                                        console.log(`Combat started. Time since end: ${timeSinceEnd}ms, AUTO_RESET_DELAY: ${AUTO_RESET_DELAY}ms, Should reset: ${shouldReset}`);
                                        
                                        if (shouldReset) {
                                            console.log("Auto-resetting due to combat restart after delay...");
                                            
                                            // 초기화 실행
                                            clearDB();
                                            lastCombatEndTime = 0;
                                            
                                            // WebSocket 재연결
                                            ws.close();
                                            setTimeout(() => {
                                                connect();
                                            }, 100);
                                            
                                            return; // 이번 업데이트는 무시
                                        }
                                    }
                                    
                                    // 현재 전투 상태 저장
                                    lastCombatActiveState = combatState.is_active;
                                }
                                
                                // Update settings
                                if (obj.data.settings) {
                                    AUTO_RESET_DELAY = (obj.data.settings.auto_reset_delay || 30) * 1000; // Convert to milliseconds
                                }
                                
                                // Update buff monitor
                                if (obj.data.buff_monitor) {
                                    buffMonitorData = obj.data.buff_monitor;
                                    updateBuffMonitor();
                                }
                                
                                if (render_timeout) return;
                                render_timeout = setTimeout(() => {
                                    renderDamageRanks();
                                    render_timeout = null;
                                }, 100);    
                                break;
                            case "test":
                                console.log("Test message:", obj.message);
                                break;
                            default:
                                console.log("Unknown message type:", obj.type);
                        }
                    } catch (e) {
                        console.log("메시지 처리 오류:", e, event.data);
                    }
                };

                ws.onclose = () => {
                    console.log("WebSocket connection closed");
                    onConnectionChanged(false);
                };

                ws.onerror = (err) => {
                    console.error("WebSocket error:", err);
                    onConnectionChanged(false);
                };
            }

            connect();
        })()
    </script>
</body>
</html>